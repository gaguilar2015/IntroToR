[
["index.html", "Learn R for Data Wrangling Chapter 1 Prerequisites 1.1 What to expect 1.2 Resources Needed: 1.3 What is R? 1.4 Is it worth learning R for data wrangling/data science as opposed to other languages like Python?", " Learn R for Data Wrangling GA for TC 2020-04-28 Chapter 1 Prerequisites 1.1 What to expect This site will cover basic and intermediate topics in learning the use of R for data wrangling and visualization. This will serve as an introduction to using R for data processing and cleaning, and also as a primer for learning R for data science. Ultimately, this site can be handy resource and reference for quickly revisiting some basic R concepts. The basics of R and RStudio will be reviewed, with some tips and tricks included, before moving on to using the Tidyverse library for manipulating, exploring and visualizing data. The main tools that will be used are RStudio and the packages in the Tidyverse library, including dplyr, tidyr, ggplot2 and readr. The general mode of operation will be to introduce R topics in sequence and to provide hand-picked apropriate online resources for those topics. However, some chapters, particularly the introductory ones, will have relatively extensive hand-written material. Other chapters might only provide summaries and supplementary comments to the provided online resources. 1.2 Resources Needed: R RStudio Web Browser This tutorial assumes that R and RStudio have already been installed, but a link to installation instructions is provided. 1.3 What is R? Such a simple question, but one worth answering. In short, the creators of the language originally defined it as ‘a programming language for data analysis and graphics’ (Ihaka and Gentleman 1996). However, it has grown to much more than that. R can now be called a powerful integrated environment for statistical and data analysis, data processing, graphics and reporting. R is open-source, meaning that the R codebase is open to users, who can contribute to the development and improvement of the language, mainly through the creation of packages for different purposes and domains. This has led to an expansion of the use of R accross academia and the industry, with applications in official statistics, data science, machine-learning, web-scraping, interactive visualizations and more! R is a powerful tool that continues to improve and expand. 1.4 Is it worth learning R for data wrangling/data science as opposed to other languages like Python? It is very much worth learning R. On the statistics side of things, R is used so extensively across academia because its tools and packages are very strongly developed and validated against standards for statistical practice and analysis. “R is probably the most thoroughly validated statistics software on Earth.” – Uwe Ligges, CRAN maintainer (useR!2017). Therefore, for somebody that works in Official Statistics or academia, R is an easy choice. However, many people working in the industry or private sector prefer other tools such as Python, especially when it comes to data science and data analytics. Are these tools better than R? Not necessarily. Although all tools, softwares and languages have their pros and cons, R offers some very compelling advantages. Firstly, R is more specialized. R was created for statisitcal analysis and data manipulation. It was built by statisticians for statisticians and therefore considered the best language for statistical analysis and modeling. For example, R provides many easy ways to deal with missing values, and it has many well-built packages for survey data analysis. R is also believed to be the best language out there for data visualization through graphs, plots, etc. Secondly, R has perhaps the best data-wrangling software on earth: Tidyverse. Tidyverse is a library containing a set of packages that vastly improve the data processing and data-wrangling capabalities of R. For example, it allows for easy reshaping, filtering, cleaning and querying of large datasets (dplyr and tidyr). It offers tools for quickly reading and writing files from different formats such as text, Excel, SPSS, STATA and more (readr package). Ggplot2 is perhaps the most popular graphing and visualization software there is, that allows plots and graphs to be build layer by layer in a very logical way. Third, R has many other extended features that will help you in your data analysis workflow. Do you need to write a report with graphs, illustrations and tables? There is RMarkdown for that. Do you need an interactive website for running statistical models and visualizations? R Shiny was created for that purpose. All of these advantages are unified by what is believed to be one of the best overall best programming IDE* out there: RStudio. RStudio is extremely powerful and flexible development environment, and it integrates all of what makes R so great. At the end of the day, it is all these advantages together that mmakes R such a commpelling sofware to learn. That beig said, Python is considered to be better at general programming, machine learning and webscraping, and the data-science field on a whole leans more towards Python. However, R is still a major player in data science and it is absolutely worth learning data science with R. In addition, you will still be able to use Python modules and commands in R using the R Package ‘Reticulate’. Reticulate allows you to import and run Python code right in R. You can have the best of both worlds! In conclusion, if you are a statistician or in academia, R is the way to go; and when you learn programming in R, you can apply these concepts later on in any other language, such as Python. Now, let’s take a look at starting to use R and RStudio. *An IDE (Integrated Developoment Environment) is a program that provides many facilities for programmers to write, test and develop programs. It usually provides tools to manage the workflow and extensions to make coding easier. RStudio is considered by many the best IDE there is. "],
["intro.html", "Chapter 2 Introduction to R and RStudio 2.1 The RStudio interface 2.2 The working directory 2.3 R and RStudio tips", " Chapter 2 Introduction to R and RStudio Now let us introduce the basic things needed for working with R: R and RStudio. For an introduction of how to download R and how to install RStudio, please refer to this link. 2.1 The RStudio interface It will is useful to find a standard way to refer to the different parts of the RStudio interface. The following image uses the best naming convention I could find. 2.1.1 The Code Editor Note that the upper-left pane is called the code editor. Although different people call it by different names, I think this one works best. Other terms for this part include “source editor” or “script editor”. This is basically where you will be doing all your typing and coding. To create a new R file or script, click on the first button on the top menu-bar and select, for example, new R script. Once this new file is created, you can start writing your R code! You can run all of the contents of an R script by clicking on the Run button in the top middle-right, or you can highlight a chunk of code in the code editor and press cmd+Enter to run that piece of code. This is very useful when testing a piece of code without having to run the entire script! 2.1.2 The R Console The console is used to execute R code directly by typing R commands into it, and it also displays the results of the executed code. Whenever you execute any command from any other part of RStudio, the console will also produce some feedback. The console is basicaly “R in interactive mode”. Note that the RConsole pane has several tabs, including Console and Terminal. What is the difference between the two? Basically, The terminal is a general command-line interface that all computers have. It is used for executing commands of many types and is not unique to R or RStudio. The Console is a subset of the terminal that is running R in interactive mode, which allows you execute R commands directly. If you wanted to use R from the terminal, you would first need to execute a separate command to call and initiate R. 2.1.3 The Workspace and History pane This pane gives you an overview of your working environment. For one, it tells you how many variables and data objects you currently have loaded into memory. You can click on data objects (such as tables) to view the contents. This is very useful when you import files and save them into R objects. Here is an example of a workspace with some data and variables (values) loaded. To see on the console all the R objects currently loaded into your R Workspace, use the ls() command ls() To remove objects from memory, use the rm() command: #removes all objects rm(list = ls()) #removes one object rm(object_name) #removes multiple objects rm(c(&quot;object1&quot;, &quot;object2&quot;, &quot;object3&quot;)) You can also save the current state of your working environment (all objects etc) so that if you close RStudio and then later you open it again, you can pick up where you left off. To do this: # save all items in workspace to a .RData file save.image() # save specified objects to a .RData file save(object1, object2, file = &quot;myfile.RData&quot;) # load workspace into current session load(&quot;myfile.RData&quot;) However, you don’t really have to this manually as RStudio automatically asks you if you want to save your workspace, and then it reloads the previously saved workspace whenever you open the project again. 2.1.4 The File and Plots (or Miscellaneous) pane The bottom right pane contains multiple tabs. The Files tab allows you to see which files are available in your working directory. The Plots tab will display any visualizations that are produced by your code. The Packages tab will list all pack- ages downloaded to your computer and also the ones that are loaded (more on this concept of packages shortly). And the Help tab allows you to search for topics you need help on and will also display any help responses (more on this later as well). 2.2 The working directory Whenever you create a new project, RStudio automatically sets your working directory to that specific folder where you created the project. What is the working directory and why is it important? The working directory (wd) is, essentially, the point of reference for the particular project you are working on. The Files pane in RStudio (lower-right pane) will display the files and folders in your current wd. And wenever you want to refer to external files in your R code, your wd will once more be your point of reference and you can use relative file-paths (relative to the wd), as opposed to absolute file paths (would need to type the entire path). For example, lets say you create a new project called DataWrangling. And in there, you create an RScript called script.R; this is where you are writing your R code. Now lets say you have a CSV file called meals.csv where you are keeping a meal schedule, and you want to manipulate some of that data in R. Well, if you copy the meals.csv file to your working directory, you can access that file using a relative path. For example, to store the contents of the file you would be able to use a command like the following: mealsFrameRelative &lt;- read.csv(&#39;meals.csv&#39;) The absolute path for the file would look like this (see how much longer it is): mealsFrameAbsolute &lt;- read.csv(&#39;Users/gian/sites/R/DataWrangling/meals.csv&#39;) In order to see your current working directory, use getwd(): getwd() To change it to somewhere else, use setwd(): setwd(&#39;path/to/new/directory&#39;) The main thing to remember is: each project will have its own working directory, usually the folder where you created the project, but this can be changed with setwd(). If you have a Mac, I suggest that you keep your R projects under User &gt; Sites &gt; R &gt; [ProjectName] For example, here I have a few projects under my Sites &gt; R directory: 2.3 R and RStudio tips 2.3.1 Organizing your working directory Usually, when you start an R projects, you will be working with a variety of different files, often of different types. For example, you have your R scripts which end with the file extension .R. You also likely will use data files such as CSV or Excel or SPSS files. If you write reports, you will also likely have PDF and Word files. A good way to organize all of these files in a logical manner is to, inside of your working directory, create the following folders: scripts - to keep your .R and .RMd (markdown) files. data - to keep all your data files that you will use to work with. reports - to keep your output documents and reports. This is how it would look in practice, if I have a project called DataWrangling and I have the previously mentioned folder structure: 2.3.2 Other ways to use R Even though RStudio is the main and preferred way to interact with R, it is not the only way. Once R is installed, it can be run from the Mac/Windows terminal using the command R, which will trigger the interactive mode and you will be able to type R commands. This is useful to remember because you can also type R myScript.R From the terminal and it will automatically execute whatever code you have in the file called myScript.R. In the programming world, we call this working from the command line (meaning, working without an interface, directly into the terminal or console). Also remember, to write R code (or any programming language), all you need is a text editor. You don’t need to use RStudio to write R, although it is preferred, and you can view/edit R files with the default text editor, or more specialized coding-oriented text editors such as VS Code. Whatever you use to write R code, you can later open it and edit it with RStudio if you prefer. This is a useful tip if you ever have to write R in a computer that does not have RStudio installed. Just remember to save the file with the .R extension. "],
["r-language-basics.html", "Chapter 3 R Language Basics 3.1 Objectives 3.2 Glossary of terms 3.3 Creating a new R project 3.4 Getting started with R code 3.5 Objects and assignment of values 3.6 Functions and arguments 3.7 Types of objects 3.8 Missing data 3.9 Installing packages 3.10 Help and documentation 3.11 Comments 3.12 Extra topic: Naming and notation 3.13 Challenge", " Chapter 3 R Language Basics 3.1 Objectives To get a refresher on the basics of R programming. To understand objects and functions. Learn how to create and use vectors. Learn how to deal with missing data. Learn how to use the help and documentation. Install and use packages. 3.2 Glossary of terms Project: An R project consisting of a main folder (as the working directory), and all the files within. Object: An R variable. This can be a single value, a vector, list, matrix, data frame or other. Almost everything in R is referred to as an object, though there are several types of objects. Function: A command in R that executes a specific action and usually returns a value. For example, the sum() function usually takes values for addition as arguments, and returns the sum. Arguments: These are values or inputs passed into functions. For example in the function sum(a, b), a and b are arguments to the sum function. These will be added and the sum will be returned. Functions usually have documentation where they specify which arguments are required for the function to work properly. Package: A package, sometimes called a library, is a set of related pre-created functions in R. It is code that has been written by other people and then packaged together so that others can download the code and re-use it. For example, if somebody were to write code about how to simulate and model the behavior of an epidemic or infectious disease, they could create a package with the related code and documentation, so that others can benefit and use it as well. 3.3 Creating a new R project To start, lets create a new project in R and call it DataWrangling. As mentioned, it is recommended to create this project in the directory user/sites/R/. Click on the File &gt; New Project and then select New Directory &gt; New Project &gt; [Select directory and enter project name] &gt; Create. Once the project is created, create a new R script by going to File &gt; New File &gt; R Script. 3.4 Getting started with R code The basis for this chapter is this excellent online resource. In addition to that, I will provide a summmary of the important points. 3.4.1 Creating objects R objects are what other languages refer to as variables or fields. They simply hold data. 3.5 Objects and assignment of values To create an objects and assign values: object1 &lt;- 5 object2 &lt;- 10 object3 &lt;- object1 + object2 3.5.1 Which assignment operator to use The traditional assignment operator in R is the left-facing arrow &lt;-. With time, the language also evolved to use the equal-sign = for this same purpoose. However, the standard practice is to always use the arrow operator &lt;- for assigning values to objects, and to use the equal sign = to specify function arguments. For example: newPerson &lt;- createNewPerson(name = &quot;John Doe&quot;, age = 45) In the previous example, the function createNewPerson() is called and two arguments (name and age) are provided. The result of the function is then assigned to the object newPerson. Note that the values provided to the arguments were specified using the equal-sign = while the assignment of the resulting value to the newPerson object was donw with the assignmment arrow operator &lt;-. Tip: Use option + - in Mac or alt + - in PC and RStudio will type in the arrow operator for you. This is very convenient and saves time and keystrokes. 3.6 Functions and arguments A function is a piece of pre-written code that takes inputs and returns a value - the result of the function. For example executing the code sum(1,3,5) takes 3 inputs and will return the value 9. Many functions have arguments that need to be provided explicitly. For example, the following function has two arguments that must be explicitly specified (written out) when __calling*__ the function. : createNewPerson(name = &quot;John Doe&quot;, age = 45) *Calling a function is the term used when a function is executed in the code. 3.7 Types of objects 3.7.1 Vectors Vectors are the most common type of object in R, and consist of a group or sequence of values (in other programming languages, vectors are called ‘arrays’). A vector is defined using the c() function. For example: ageVector &lt;- c(19,22,20,18,18,19,22,21) In the previous code, I created a vector called ageVector by using the c() function to combine a group of values into a single vector. There are several R functions that help you get information on vectors (and other objects), such as: length(): Tells you the number of elements (distinct values) in the vector. class(): The type of data contained in the vector (such as numeric or string/character) str(): Detailed information about the structure and contents of the vector, including length and class, but other details as well. Try copying and running the following code to compare the results: ageVector &lt;- c(19,22,20,18,18,19,22,21) length(ageVector) class(ageVector) str(ageVector) 3.7.1.1 Add elements to a vector At the beginning: ageVector &lt;- c(20, ageVector) At the end: ageVector &lt;- c(ageVector, ageVector) 3.7.1.2 Subsetting vectors Subsetting is the process of obtaining one or more elements (a subset) of a given vector or object. Subset vectors by using brackets [] after the object name and then specifying the index of the element/value you are interested in. Return the first value in the vector: ageVector[1] Return the first, second and fourth values: ageVector[c(1,2,4)] Return all values except the first: ageVector[-1] Return all values except the first, third and fifth values: ageVector[-c(1,3,5)] Returns all values between the second and fifth, inclusive. ageVector[2:5] 3.7.1.3 Conditional Subsetting You can use conditions to only return certain values in a matrix - those which satisfy the conditions. Return all ages &gt; 20: ageVector[ageVector &gt; 20] Boolean (TRUE/FALSE) values can also be used for subsetting. Elmenents that correspond to TRUE will be returned, and FALSE will not. In the following code, the first element is retured, the second is not, the third is, the fourth and fifth are not, etc… ageVector[c(TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE)] Another way to write the same code: boolVector &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE) ageVector[boolVector] 3.7.2 Matrix A matrix consists of rows and columns. All columns must be of the same length as well as all rows (Eg: cant have a row with 3 entries and another with 5). To construct a matrix, we use a function conveniently called matrix(). y &lt;- matrix(1:20, nrow=5,ncol=4) # generates 5 x 4 numeric matrix Subset a matrix with [row , column]: y[,4] # 4th column of matrix y[3,] # 3rd row of matrix y[2:4,1:3] # rows 2,3,4 of columns 1,2,3 3.7.3 List Lists can have elements of any type and length. To construct one, use the list() function: myl &lt;- list(id=&quot;ID_1&quot;, a_vector=animals, a_matrix=y, age=5.3) # example of a list with 4 components myl[[2]] # 2nd component of the list myl[[&quot;id&quot;]] # component named id in list 3.7.4 Data frame Data frames in R is like a mixture of lists and matrices. You have a set named columns each of which can be of different type (like in a list), but all columns must be of same length (like in a matrix). A way to think about a data frame is like a table in Excel and is commonly used to store tabular-type data. Here is how you could construct a data frame. mydf &lt;- data.frame(ID=c(1:4), Color=c(&quot;red&quot;, &quot;white&quot;, &quot;red&quot;, NA), Passed=c(TRUE,TRUE,TRUE,FALSE), Weight=c(99, 54, 85, 70), Height=c(1.78, 1.67, 1.82, 1.59)) mydf 3.8 Missing data R automatically codes missing data with the NA value. Datasets that have missing data can be processed with a variety of ways that will help you decide how to deal with these missing values. Dealing with missing values is important when operating with rows and columns of data. For example, you might want to add all values in a row to get a total, but what happens if you have a bunch of NAs? There are two main ways: Using the na.rm argument. Many functions such as sum() and mean() have an argument called na.rm (basically: NA remove) which you can set to TRUE in order to ignore missing values. For example: heightVector &lt;- c(110, 120, NA, NA, 100, NA) avgHeight &lt;- mean(heightVector, na.rm = TRUE) Use functions such as na.omit() or is.na(). For example: heightVector &lt;- c(110, 120, NA, NA, 100, NA) avgHeight &lt;- mean(na.omit(heightVector)) or heightVector &lt;- c(110, 120, NA, NA, 100, NA) avgHeight &lt;- mean(!is.na(heightVector)) Note the exlamation point before !is.na(), which makes sure that the function returns the values that are not NA. Otherwise, is.na() returns values that are NA. The exclamation point negates or reverses the operation. 3.9 Installing packages There are two steps for using a package: Download the package via the console: install.packages(\"name_of_package\") Include the package at the top of the R Script where you want to use it, by using the library function: library(\"name_of_package) 3.10 Help and documentation For general R help, look at the ‘Help’ tab in the Files and Miscellaneous pane. For quick help relating to any function or package, use the question mark ? before the name of a function or package. ?sum Will open up the documentation for the sum() function and tell you how to use it. When writing R code, you will definitely run into situations where you are not sure what to do and you need help; or you might get an error that you do not understand. For these situations, you have two good friends: Google and StackOverflow.com. These tools are truly a programmer’s best friends. Stack Overlow is a Q&amp;A community where people ask all types of programming questions, including most of the ones you will ever ask. So you can probably find the answer to your question there. 3.11 Comments Use the pound or hash sign # to write comments in your code. Comments are non-executable pieces of writing that help explain your code. Sometimes, it is useful to “comment out” R code that is not currently being used, or when you want intend to delete a piece of code but are not sure yet if it is the write decision. You can add # to the beginning of each line of code that you want to be skipped during execution. Tip: To comment out large chunks of code at a time, select/highlight the code and then use commmand + shift + c (or ctrl + shift + c in Windows). Select the same code and press the same sequence of keys to un-comment the code later, if necessary. 3.12 Extra topic: Naming and notation Objects or variables can have practically any namme, but there are some rules: Cannot start with a number, but can have numbers in the name. 1time is not valid, but time1 and time1result are valid. Cannot be one of key-words or reserved words in R. For example, terms such as if, else, for, and function already have specific uses in R and cannot be used for names of objects. Must be descriptive, but succint. Are case sensitive: value1 is not the same as Value1, these are different objects. In addition, there are several styles for naming and writing object names, especially if the name consists of more than one “English” word. For example, I previously referred to an object called newPerson. A different programmer maybe would have preferred to name it new_person instead. This is what we refer to when we talk about naming-styles or naming-conventions. The main styles are as follows: Camel-case: the first word is small-letters, but all other words start with a capital letter. Eg: newPerson, verySmallChild, totalSum. Underscore sepatator: Uses underscores _ to separate the words. Eg: new_person, very_small_child, total_sum. All small: The entire name is in small letters. Eg; newperson, verysmallchild, totalsum. The important thing about notation styling is to just be consistent. I personally preferr to use camelCase for object and variable notation in programming language. However, when working with databases and the SQL language, it is recommended to use underscore_separators to name your tables and table-fields (columns). Therefore, when creating tables (or data frames) in R, I will typically use underscore_separators when naming the columns; but I will use camelCase for the names of any other kind of object. Eg: salesTable &lt;- data.table(value_one, value_two, total_sales) The previous example is not really valid R code, but it illustrates the naming convention principles that were previously discussed. 3.13 Challenge "],
["data-manipulation-with-dplyr.html", "Chapter 4 Data Manipulation with dplyr 4.1 Objectives 4.2 Importing Data 4.3 The pipe %&gt;% operator 4.4 Subsetting data with Dplyr", " Chapter 4 Data Manipulation with dplyr Now lets get directly into data wrangling! Data wrangling is the process of preparing data for analysis. It often feels like you are fighting or ‘wrangling’ with the data to get it to a neat and useful state, hence the name. Things involved in data wrangling include importing data, subsetting data (selecting only the rows and columns you need), reshaping data, merging data and deriving new fields in the data. In the data-analysis workflow, data wrangling encompasses the first phase, a very important one. So, let us learn how to do this. For the purpose of data wrangling, we will use the Tidyverse library, which is a set of packages written especially for working with data. ‘Tidyverse’ is actually a collection of packages for data-manipulation and visualization. Specific packages in this library include dplyr (data manipulation), tidyr (data reshaping) and ggplot (plots and visualizations). For the purpose of this document, most of the functions/commands we will use come from the dplyr package. Note: this online tutorial is also a very good and recommended tutorial for learning data manipulation with dplyr, and some of the examples there might be used throughout the chapter. 4.1 Objectives Learn how to import data in many formats. Learn about the pipe operator (%&gt;%) Learn how to subset data. Learn how to group and summarize data. Learn how to merge or join different datasets. 4.2 Importing Data The first step in data wrangling is actually obtaining the data that you will be working with. Data comes in different shapes, sizes and formats, so it is important to know how to import and read these in R. We will now see how to import different formats of data and which packages and commands to use to do this. 4.2.1 Importing Excel data There are many different packages that can be used to read Excel files, but we will choose one that combines speed and flexibility: the xlsx package; this package allows both reading from and writing to Excel. Install it and load it using the commands: #install install.packages(&quot;xlsx&quot;) #load library(xlsx) Then, use the read.xlsx2 function to import an Excel file (the package also contains an identical function called read.xlsx but read.xlsx2 is faster when working with large files). So if we have a file named ‘mydata.xlsx’ inside the ‘data’ folder in our working directory, we would import it like this: myExcelData &lt;- read.xlsx2(&quot;data/mydata.xlsx&quot;, 1) The second argument (‘1’) is the index of the sheet to read, so if you were to have multiple sheets and wanted to read the third one, the command would be: myExcelData &lt;- read.xlsx2(&quot;data/mydata.xlsx&quot;, 3) You can take a quick look at the contents of your imported data in the following ways: #View entire dataset View(myExcelData) #View first 5 rows head(myExcelData, 5) #Use the same &#39;head&#39; function but using pipes: myExcelData %&gt;% head(5) 4.2.2 Importing CSV or text data Just as with Excel, there are many ways to read text and CSV files. However, perhaps the easiest way is to use the read.table function. Below you can see how to use this function to read different kind of text files. #read a CSV file with comma separators myCSVData &lt;- read.table(&quot;myData.csv&quot;, sep = &quot;,&quot;) #read a CSV file with semi-colon separators myCSVData &lt;- read.table(&quot;myData.csv&quot;, sep = &quot;;&quot;) #read a tab-delimited text file myCSVData &lt;- read.table(&quot;myData.csv&quot;, sep = &quot;\\t&quot;) As you can see, this function takes two main arguments: the path to file, and the separator (sep) used in the chosen file. Note that although CSV stands for “Comma Separated Values”, you will sometimes find that these files are separated by semi-colons, tabs or even spaces. This is why the ‘sep’ argument must be specified. You can look into the content of your imported data the same way as we did in the Excel section. 4.2.3 Importing SPSS data Why would we want to import data in the SPSS format into R, instead of using another format? There are two main reasons. A lot of datasets already exist in SPSS format, especially survey data. We have a lot of SPSS datasets at the SIB from past surveys and activities. SPSS files keep the value labels for the fields and options, something that is very important for understanding a dataset. Therefore, if we want our final outputs, after wrangling and analysing the data, to also have useful value labels without having to create them ourselves, we can import data in the SPSS format (or other labeled data-formats). There are two main libraries for importing SPSS data: Haven and Foreign. For the purpose of this guide, we will be using the ‘haven’ library,which can also import data that in STATA, SAS and other formats. Haven gives us the advantage of providing us with “tibbles” which are a modern version of dataframes that provide smarter printing and other advantages. Tibbles can also be converted back to regular dataframes using as.data.framme(tibble_name). To read an SPSS file using Haven: mySPSSdata &lt;- read_sav(&quot;spssdata.sav&quot;) Notice that we did not have to provide any additional arguments to the function. If we had used Foreign,we would have needed to provide extra parameters to the function. On the other hand, Foreign is a bit more flexible, while Haven is easier. You can then see the contents of your imported file: #view all data View(mySPSSdata) #view first 10 rows mySPSSdata %&gt;% head(10) You can create an SPSS file from a dataframe using the write_sav function: #write SPSS sav file write_sav(myDataframe, &quot;myNewFile.sav&quot;) Before we start practicing with data, let’s briefly introduce an important dplyr operator: the pipe operator. 4.3 The pipe %&gt;% operator The pipe operator (%&gt;%) is very useful because it allows us to chain commands from left to right. This means that the result of one command can be passed directly to another command. It goes something like this: #execute three commands, passing the result of the first to the second, and of the second to the third dataframe %&gt;% command1 %&gt;% commmand2 %&gt;% command3 #the same as before but now saving the result to an object result &lt;- dataframe %&gt;% command1 %&gt;% command2 %&gt;% commmand3 Two important thing to remember: When starting a pipe sequence, the first item to the LEFT of the pipe is the object or dataframe that will be USED by the commands in the pipe. In the example above, dataframe is PASSED to command1, then the results of that is passed to command2, etc. When using pipes and other tidyverse commands, these commands do not permanently modify the data UNLESS you save the results by assigning it to an object. In the previous example, running command1, command2 and command3 does not cause permanent changes until it was saved to an object called ‘result’, which will store the results of the operations. 4.4 Subsetting data with Dplyr Now that we know how to read and import data, as well as how to use the pipe operator, we can start looking at how to work with and manipulate data. One of the most common operations on data is subsetting it; this means: only selecting some of the columns and some of the rows. The two important Dplyr functions that we will be using for this purpose are: filter: for specifying which rows to keep based on a condition that must be satisfied. select: for specifying which columns should be kept. Columns can be specified either by name or index/position. We will be practicing examples by playing with some dummy data from an imaginary Labour Force Survey. A few of the columns and the first 5 rows of this dataset are shown below. ## ## Attaching package: &#39;kableExtra&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## group_rows district ed household individual_name age sex is_employed finalresult 1 101 11 Carmen Deer 24 female TRUE Complete 2 102 12 John Smith Sr. 48 male TRUE Partially Complete 3 103 12 John Smith Jr 24 male FALSE Complete 4 104 13 Pedro Dias 35 male TRUE Complete 5 105 13 Amira Dias 33 female NA REFUSAL The following examples will show how to do some common subsetting operations. We will be referring to the LFS table that we created earlier in this section. 4.4.1 Using filter First, let’s see how to use the filter function: #- display rows containing indivuals ages 14 and over lfsData %&gt;% filter(age &gt;= 14, age != 999) ## district ed household individual_name age sex is_employed ## 1 1 101 11 Carmen Deer 24 female TRUE ## 2 2 102 12 John Smith Sr. 48 male TRUE ## 3 3 103 12 John Smith Jr 24 male FALSE ## 4 4 104 13 Pedro Dias 35 male TRUE ## 5 5 105 13 Amira Dias 33 female NA ## finalresult ## 1 Complete ## 2 Partially Complete ## 3 Complete ## 4 Complete ## 5 REFUSAL #- save rows containing females that are unemployed unemployedFemales &lt;- lfsData %&gt;% filter(sex == &quot;female&quot;, is_employed == TRUE) In the previous example, the first expression filters respondents who are over 14 (and not 999 which is a special value for ‘missing’), and prints/displays the results. The second expression filters respondents who are female and who are employed and does not display the results but instead SAVES them in the unemployedFemales object. Import to remember about the filter function: You use the R comparison operators to create conditions, such as == (equal to), != (not equal to), &gt; (greater than), &lt;= (less than or equal to). You can specify more than one condition, separating them using commas. Eg: filter(condition1, condition2, condition3). You can als use the OR operator, where AT LEAST one of your listed conditions must be true. For this, use |. (Example: fattyfoods &lt;- allfoods %&gt;% filter(foodgroup == \"fats\" | fatcontent &gt; 0.5). The above example can be read in plain English as: “From the allfoods dataframe, filter the rows where the value in the foodgroup column is”fats\", OR where the value in the fatcontent column is greater than 0.5, and save these rows in the fattyfoods object. 4.4.2 Using select Now lets see how to use the select function: ##-- Using select without saving results #- display the &#39;age&#39; and &#39;finalresult&#39; columns of the dataset lfsData %&gt;% select(age, finalresult) ## age finalresult ## 1 24 Complete ## 2 48 Partially Complete ## 3 24 Complete ## 4 35 Complete ## 5 33 REFUSAL ##-- Using select AND saving the results #- save the &#39;district&#39;, &#39;age&#39; and &#39;finalresult&#39; columns of the dataset myDistrictData &lt;- lfsData %&gt;% select(district, age, finalresult) Now lets put use the two commands together: ##-- Using select and filter together #- display the interview__key and name for unemployed males in the dataset lfsData %&gt;% filter(sex == &quot;male&quot;, is_employed == FALSE) %&gt;% select(individual_name, finalresult) ## individual_name finalresult ## 1 John Smith Jr Complete #- The same command as before but now saving the results unemployedMales &lt;- lfsData %&gt;% filter(sex == &quot;male&quot;, is_employed == FALSE) %&gt;% select(individual_name, finalresult) As you see in the previous examples, when you are chaining operations with a pipe, it is good to start each operation on a new line. This makes for cleaner, much more readable code. The best thing about DPLYR is that it makes manipulating data so clean to read and write!! For comparison, here is how you would write the previous example using plain R: ##-- Using select and filter together #- display the interview__key and name for unemployed males in the dataset lfsData[lfsData$sex == &quot;male&quot; &amp; lfsData$is_employed == FALSE, c(&quot;individual_name&quot;, &quot;finalresult&quot;)] #- The same command as before but now saving the results unemployedMales &lt;- lfsData[lfsData$sex == &quot;male&quot; &amp; lfsData$is_employed == FALSE, c(&quot;individual_name&quot;, &quot;finalresult&quot;)] As we can see, we can still do subsetting in base/plain R, but it is more confusing to read and write!! DPLYR allows you to use explicit action words such as SELECT and FILTER that automatically let your brain know what is going on. "]
]
